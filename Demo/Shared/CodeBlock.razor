@inject IJSRuntime JSRuntime
@inject HttpClient HttpClient
@implements IAsyncDisposable

<MudPaper Class="code-block-container" Outlined="true" Elevation="0">
    <div class="code-block-header">
        <MudText Typo="Typo.caption" Class="code-language-label">@GetLanguageLabel()</MudText>
        <MudSpacer />
        @if (ShowCopyButton)
        {
            <MudButton Variant="Variant.Text"
                       Size="Size.Small"
                       StartIcon="@(_codeCopied ? Icons.Material.Filled.Done : Icons.Material.Filled.ContentCopy)"
                       Color="@(_codeCopied ? Color.Success : Color.Default)"
                       OnClick="CopyCode"
                       Class="code-copy-btn">
                @(_codeCopied ? "Copied!" : "Copy")
            </MudButton>
        }
    </div>
    <div class="code-block-content">
        <pre class="@($"language-{Language}")"><code>@GetDisplayCode()</code></pre>
    </div>
</MudPaper>

@code {
    [Parameter] public string? Code { get; set; }
    [Parameter] public string? CodeFile { get; set; }
    [Parameter] public string Language { get; set; } = "csharp";
    [Parameter] public bool ShowCopyButton { get; set; } = true;

    private bool _codeCopied;
    private string _displayCode = "";
    private string _previousCode = "";
    private bool _needsHighlighting;

    protected override async Task OnInitializedAsync()
    {
        if (!string.IsNullOrEmpty(CodeFile))
        {
            try
            {
                _displayCode = await HttpClient.GetStringAsync(CodeFile);
                _previousCode = _displayCode;
            }
            catch
            {
                _displayCode = $"// Error loading code from {CodeFile}";
                _previousCode = _displayCode;
            }
        }
        else if (!string.IsNullOrEmpty(Code))
        {
            _displayCode = Code;
            _previousCode = Code;
        }
    }

    protected override void OnParametersSet()
    {
        // Only update if Code parameter is being used (not CodeFile)
        if (string.IsNullOrEmpty(CodeFile) && !string.IsNullOrEmpty(Code) && Code != _previousCode)
        {
            _previousCode = Code;
            _needsHighlighting = true;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        var currentCode = GetDisplayCode();
        if ((firstRender || _needsHighlighting) && !string.IsNullOrEmpty(currentCode))
        {
            _needsHighlighting = false;
            try
            {
                // Small delay to ensure DOM is updated
                await Task.Delay(100);
                await JSRuntime.InvokeVoidAsync("highlightCode");
            }
            catch
            {
                // Ignore errors from Prism.js highlighting
            }
        }
    }

    private async Task CopyCode()
    {
        var codeToCopy = GetDisplayCode();
        await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", codeToCopy);
        _codeCopied = true;
        StateHasChanged();

        await Task.Delay(2000);
        _codeCopied = false;
        StateHasChanged();
    }

    private string GetDisplayCode()
    {
        // For file-based code, use cached version
        if (!string.IsNullOrEmpty(CodeFile))
        {
            return _displayCode;
        }

        // For parameter-based code, always use the current parameter
        return Code ?? "";
    }

    private string GetLanguageLabel()
    {
        return Language switch
        {
            "csharp" => "C#",
            "razor" => "Razor",
            "html" => "HTML",
            "css" => "CSS",
            "javascript" or "js" => "JavaScript",
            "json" => "JSON",
            "xml" => "XML",
            "bash" => "Bash",
            _ => Language.ToUpper()
        };
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            // Reset Prism highlighting markers if needed
            await JSRuntime.InvokeVoidAsync("PrismWrapper.reset");
        }
        catch
        {
            // Ignore errors during disposal
        }
    }
}
